{"version":3,"sources":["webpack:///node_modules/@ledgerhq/hw-app-eth/lib-es/Eth.js","webpack:///node_modules/@ledgerhq/hw-app-eth/lib-es/utils.js"],"names":["starkQuantizationTypeMap","eth","erc20","erc721","erc20mintable","erc721mintable","hexBuffer","str","Buffer","from","startsWith","slice","maybeHexBuffer","remapTransactionRelatedErrors","e","statusCode","Eth","transport","scrambleKey","decorateAppAPIMethods","path","boolDisplay","boolChaincode","paths","buffer","alloc","length","forEach","element","index","writeUInt32BE","send","then","response","result","publicKeyLength","addressLength","publicKey","toString","address","chainCode","data","rawTxHex","offset","rawTx","toSend","rlpTx","rlpOffset","chainIdPrefix","rlpVrs","chainIdSrc","chainIdBuf","copy","readUInt32BE","maxChunkSize","chunkSize","push","i","apduResponse","v","r","s","arbitraryDataEnabled","erc20ProvisioningNecessary","starkEnabled","starkv2Supported","version","messageHex","message","domainSeparatorHex","hashStructMessageHex","domainSeparator","hashStruct","sourceTokenAddress","sourceQuantization","destinationTokenAddress","destinationQuantization","sourceVault","destinationVault","amountSell","amountBuy","nonce","timestamp","sourceTokenAddressHex","destinationTokenAddressHex","padStart","sourceQuantizationType","sourceMintableBlobOrTokenId","destinationQuantizationType","destinationMintableBlobOrTokenId","Error","transferTokenAddress","transferQuantization","targetPublicKey","amountTransfer","transferTokenAddressHex","targetPublicKeyHex","transferQuantizationType","transferMintableBlobOrTokenId","conditionalTransferAddress","conditionalTransferFact","conditionalTransferAddressHex","operationContract","operationQuantization","operationContractHex","operationQuantizationType","operationMintableBlobOrTokenId","hash","hashHex","withdrawalIndex","defer","resolve","reject","promise","Promise","success","failure","splitPath","components","split","number","parseInt","isNaN","eachSeries","arr","fun","reduce","p","foreach","callback","iterate","array","res","doIf","condition","asyncWhile","predicate"],"mappings":"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","file":"ledgerhq-hw-app-eth-es5.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport { BigNumber } from \"bignumber.js\";\nimport { encode, decode } from \"rlp\";\nconst starkQuantizationTypeMap = {\n  eth: 1,\n  erc20: 2,\n  erc721: 3,\n  erc20mintable: 4,\n  erc721mintable: 5\n};\n\nfunction hexBuffer(str) {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nfunction maybeHexBuffer(str) {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nconst remapTransactionRelatedErrors = e => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\"Please enable Contract data on the Ethereum app Settings\");\n  }\n\n  return e;\n};\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\n\n\nexport default class Eth {\n  constructor(transport, scrambleKey = \"w0w\") {\n    this.transport = void 0;\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getAddress\", \"provideERC20TokenInformation\", \"signTransaction\", \"signPersonalMessage\", \"getAppConfiguration\", \"signEIP712HashedMessage\", \"starkGetPublicKey\", \"starkSignOrder\", \"starkSignOrder_v2\", \"starkSignTransfer\", \"starkSignTransfer_v2\", \"starkProvideQuantum\", \"starkProvideQuantum_v2\", \"starkUnsafeSign\", \"eth2GetPublicKey\", \"eth2SetWithdrawalIndex\"], scrambleKey);\n  }\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n\n\n  getAddress(path, boolDisplay, boolChaincode) {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer).then(response => {\n      let result = {};\n      let publicKeyLength = response[0];\n      let addressLength = response[1 + publicKeyLength];\n      result.publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n      result.address = \"0x\" + response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString(\"ascii\");\n\n      if (boolChaincode) {\n        result.chainCode = response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString(\"hex\");\n      }\n\n      return result;\n    });\n  }\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n\n\n  provideERC20TokenInformation({\n    data\n  }) {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n        // we return a flag to know if the call was effective or not\n        return false;\n      }\n\n      throw e;\n    });\n  }\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n\n\n  signTransaction(path, rawTxHex) {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response; // Check if the TX is encoded following EIP 155\n\n    let rlpTx = decode(rawTx);\n    let rlpOffset = 0;\n    let chainIdPrefix = \"\";\n\n    if (rlpTx.length > 6) {\n      let rlpVrs = encode(rlpTx.slice(-3));\n      rlpOffset = rawTx.length - (rlpVrs.length - 1);\n      const chainIdSrc = rlpTx[6];\n      const chainIdBuf = Buffer.alloc(4);\n      chainIdSrc.copy(chainIdBuf, 4 - chainIdSrc.length);\n      chainIdPrefix = (chainIdBuf.readUInt32BE(0) * 2).toString(16).slice(0, -2); // Drop the low byte, that comes from the ledger.\n    }\n\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;\n\n      if (rlpOffset != 0 && offset + chunkSize == rlpOffset) {\n        // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n        chunkSize--;\n      }\n\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n\n    return foreach(toSend, (data, i) => this.transport.send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = chainIdPrefix + response.slice(0, 1).toString(\"hex\");\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    }, e => {\n      throw remapTransactionRelatedErrors(e);\n    });\n  }\n  /**\n   */\n\n\n  getAppConfiguration() {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.erc20ProvisioningNecessary = response[0] & 0x02;\n      result.starkEnabled = response[0] & 0x04;\n      result.starkv2Supported = response[0] & 0x08;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\n  eth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n\n\n  signPersonalMessage(path, messageHex) {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n\n    return foreach(toSend, (data, i) => this.transport.send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    });\n  }\n  /**\n  * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n  * @example\n  eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n\n\n  signEIP712HashedMessage(path, domainSeparatorHex, hashStructMessageHex) {\n    const domainSeparator = hexBuffer(domainSeparatorHex);\n    const hashStruct = hexBuffer(hashStructMessageHex);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    domainSeparator.copy(buffer, offset);\n    offset += 32;\n    hashStruct.copy(buffer, offset);\n    return this.transport.send(0xe0, 0x0c, 0x00, 0x00, buffer).then(response => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n\n\n  starkGetPublicKey(path, boolDisplay) {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer).then(response => {\n      return response.slice(0, response.length - 2);\n    });\n  }\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignOrder(path, sourceTokenAddress, sourceQuantization, destinationTokenAddress, destinationQuantization, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x01, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * sign a Stark order using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantizationType quantization type used for the source token\n   * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)\n   * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantizationType quantization type used for the destination token\n   * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)\n   * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignOrder_v2(path, sourceTokenAddress, sourceQuantizationType, sourceQuantization, sourceMintableBlobOrTokenId, destinationTokenAddress, destinationQuantizationType, destinationQuantization, destinationMintableBlobOrTokenId, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n\n    if (!(sourceQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkSignOrderv2 invalid source quantization type=\" + sourceQuantizationType);\n    }\n\n    if (!(destinationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkSignOrderv2 invalid destination quantization type=\" + destinationQuantizationType);\n    }\n\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 1 + 20 + 32 + 32 + 1 + 20 + 32 + 32 + 4 + 4 + 8 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];\n    offset++;\n\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (sourceQuantization) {\n      Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (sourceMintableBlobOrTokenId) {\n      Buffer.from(sourceMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n    buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];\n    offset++;\n\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (destinationQuantization) {\n      Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (destinationMintableBlobOrTokenId) {\n      Buffer.from(destinationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x03, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignTransfer(path, transferTokenAddress, transferQuantization, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp) {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x02, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * sign a Stark transfer or conditional transfer using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantizationType quantization type used for the token to be transferred\n   * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @option conditionalTransferAddress onchain address of the condition for a conditional transfer\n   * @option conditionalTransferFact fact associated to the condition for a conditional transfer\n   * @return the signature\n   */\n\n\n  starkSignTransfer_v2(path, transferTokenAddress, transferQuantizationType, transferQuantization, transferMintableBlobOrTokenId, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp, conditionalTransferAddress, conditionalTransferFact) {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    const conditionalTransferAddressHex = maybeHexBuffer(conditionalTransferAddress);\n\n    if (!(transferQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkSignTransferv2 invalid quantization type=\" + transferQuantizationType);\n    }\n\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 1 + 20 + 32 + 32 + 32 + 4 + 4 + 8 + 4 + 4 + (conditionalTransferAddressHex ? 32 + 20 : 0), 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];\n    offset++;\n\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (transferQuantization) {\n      Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (transferMintableBlobOrTokenId) {\n      Buffer.from(transferMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n\n    if (conditionalTransferAddressHex && conditionalTransferFact) {\n      offset += 4;\n      Buffer.from(conditionalTransferFact.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n      offset += 32;\n      conditionalTransferAddressHex.copy(buffer, offset);\n    }\n\n    return this.transport.send(0xf0, 0x04, conditionalTransferAddressHex ? 0x05 : 0x04, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n\n\n  starkProvideQuantum(operationContract, operationQuantization) {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    let buffer = Buffer.alloc(20 + 32, 0);\n\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n\n    Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting Stark extensions\n        return false;\n      }\n\n      throw e;\n    });\n  }\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantizationType quantization type of the token to be transferred\n   * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred\n   */\n\n\n  starkProvideQuantum_v2(operationContract, operationQuantizationType, operationQuantization, operationMintableBlobOrTokenId) {\n    const operationContractHex = maybeHexBuffer(operationContract);\n\n    if (!(operationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkProvideQuantumV2 invalid quantization type=\" + operationQuantizationType);\n    }\n\n    let buffer = Buffer.alloc(20 + 32 + 32, 0);\n    let offset = 0;\n\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (operationQuantization) {\n      Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (operationMintableBlobOrTokenId) {\n      Buffer.from(operationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    return this.transport.send(0xf0, 0x08, starkQuantizationTypeMap[operationQuantizationType], 0x00, buffer).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting Stark extensions\n        return false;\n      }\n\n      throw e;\n    });\n  }\n  /**\n   * sign the given hash over the Stark curve\n   * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.\n   * @param path a path in BIP 32 format\n   * @param hash hexadecimal hash to sign\n   * @return the signature\n   */\n\n\n  starkUnsafeSign(path, hash) {\n    const hashHex = hexBuffer(hash);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    hashHex.copy(buffer, offset);\n    return this.transport.send(0xf0, 0x0a, 0x00, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a publicKey\n   * @example\n   * eth.eth2GetPublicKey(\"12381/3600/0/0\").then(o => o.publicKey)\n   */\n\n\n  eth2GetPublicKey(path, boolDisplay) {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer).then(response => {\n      let result = {};\n      result.publicKey = response.slice(0, -2).toString(\"hex\");\n      return result;\n    });\n  }\n  /**\n   * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature\n   *\n   * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0\n   *\n   * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0\n   * @return True if the method was executed successfully\n   */\n\n\n  eth2SetWithdrawalIndex(withdrawalIndex) {\n    let buffer = Buffer.alloc(4, 0);\n    buffer.writeUInt32BE(withdrawalIndex, 0);\n    return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting ETH 2\n        return false;\n      }\n\n      throw e;\n    });\n  }\n\n}\n//# sourceMappingURL=Eth.js.map","/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\nexport function defer() {\n  let resolve, reject;\n  let promise = new Promise(function (success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw \"defer() error\"; // this never happens and is just to make flow happy\n\n  return {\n    promise,\n    resolve,\n    reject\n  };\n} // TODO use bip32-path library\n\nexport function splitPath(path) {\n  let result = [];\n  let components = path.split(\"/\");\n  components.forEach(element => {\n    let number = parseInt(element, 10);\n\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n\n    result.push(number);\n  });\n  return result;\n} // TODO use async await\n\nexport function eachSeries(arr, fun) {\n  return arr.reduce((p, e) => p.then(() => fun(e)), Promise.resolve());\n}\nexport function foreach(arr, callback) {\n  function iterate(index, array, result) {\n    if (index >= array.length) {\n      return result;\n    } else return callback(array[index], index).then(function (res) {\n      result.push(res);\n      return iterate(index + 1, array, result);\n    });\n  }\n\n  return Promise.resolve().then(() => iterate(0, arr, []));\n}\nexport function doIf(condition, callback) {\n  return Promise.resolve().then(() => {\n    if (condition) {\n      return callback();\n    }\n  });\n}\nexport function asyncWhile(predicate, callback) {\n  function iterate(result) {\n    if (!predicate()) {\n      return result;\n    } else {\n      return callback().then(res => {\n        result.push(res);\n        return iterate(result);\n      });\n    }\n  }\n\n  return Promise.resolve([]).then(iterate);\n}\n//# sourceMappingURL=utils.js.map"]}